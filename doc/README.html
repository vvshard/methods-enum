<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Attribute-like macro &#39;methods_enum::gen&#39;</title>

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Attribute-like macro &#39;methods_enum::gen&#39;</h1>
    <p>Lightweight (no dependencies) attribute-like macro for “state” and “state machine” design patterns without dyn Trait (based on <code>enum</code>) with decoding output in doc-comments.</p>
<p>The macro attribute is set before the direct <code>impl</code> block (no trait). Based on the method signatures of the <code>impl</code> block, it generates: <code>enum</code> with options from argument tuples, and generates the <code>{}</code> bodies of these methods with the call of the argument handler method from this <code>enum </code>.</p>
<p>This allows the handler method to control the behavior of the methods depending on the context.</p>
<p>There are two syntax options:</p>
<ol>
<li>For the case where methods returning a value have the same return type:</li>
</ol>
<p><strong><code>#[methods_enum::gen(</code><em>EnumName</em><code>: </code> <em>handler_name</em><code>)]</code></strong></p>
<p>where:</p>
<ul>
<li><em>EnumName</em>: the name of the automatically generated enum.</li>
<li><em>handler_name</em>: handler method name</li>
</ul>
<ol start="2">
<li>In case of more than one meaningful return type:</li>
</ol>
<p><strong><code>#[methods_enum::gen(</code><em>EnumName</em><code>: </code> <em>handler_name</em> <code>=</code> <em>OutName</em><code>)]</code></strong></p>
<p>where:</p>
<ul>
<li><em>OutName</em>: the name of the automatically generated enum with options from single tuples of return types.</li>
</ul>
<p>In the second case, you can also specify an expression for the default return value after the method signature.</p>
<h2 id="usage-example"><a href="#usage-example">Usage example</a></h2>
<p><a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html">Chapter 17.3 “Implementing an Object-Oriented Design Pattern” of the rust-book</a> shows an implementation of the <em>state pattern</em> in rust that provides the following behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">post</span> <span class="op">=</span> <span class="ident">blog::Post::new</span>();

    <span class="ident">post</span>.<span class="ident">add_text</span>(<span class="string">&quot;I ate a salad for lunch today&quot;</span>);
    <span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());

    <span class="ident">post</span>.<span class="ident">request_review</span>();
    <span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());

    <span class="ident">post</span>.<span class="ident">approve</span>();
    <span class="macro">assert_eq!</span>(<span class="string">&quot;I ate a salad for lunch today&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());
}
</code></pre></div>
<p>The dyn Trait option proposed in the book requires dynamic binding and duplication of logic. 
The option on different types is not applicable in cases where a single interface is required for states.</p>
<p>By setting in Cargo.toml:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
methods-enum = &quot;0.1.1&quot;</code></pre></div>
<p>this can be solved, for example, like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod</span> <span class="ident">blog</span> {
    <span class="kw">enum</span> <span class="ident">State</span> {
        <span class="ident">Draft</span>,
        <span class="ident">PendingReview</span>,
        <span class="ident">Published</span>,
    }

    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Post</span> {
        <span class="ident">state</span>: <span class="ident">State</span>,
        <span class="ident">content</span>: <span class="ident">String</span>,
    }

    <span class="attribute">#[<span class="ident">methods_enum::gen</span>(<span class="ident">Meth</span>: <span class="ident">run_methods</span>)]</span>
    <span class="kw">impl</span> <span class="ident">Post</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_text</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">text</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">request_review</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">approve</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">content</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span>;

        <span class="kw">fn</span> <span class="ident">run_methods</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">method</span>: <span class="ident">Meth</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span> {
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span> {
                <span class="ident">State::Draft</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::add_text</span>(<span class="ident">text</span>) =&gt; { <span class="self">self</span>.<span class="ident">content</span>.<span class="ident">push_str</span>(<span class="ident">text</span>); <span class="string">&quot;&quot;</span> }
                    <span class="ident">Meth::request_review</span>() =&gt; { <span class="self">self</span>.<span class="ident">state</span> <span class="op">=</span> <span class="ident">State::PendingReview</span>; <span class="string">&quot;&quot;</span> }
                    <span class="kw">_</span> =&gt; <span class="string">&quot;&quot;</span>,
                },
                <span class="ident">State::PendingReview</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::approve</span>() =&gt; { <span class="self">self</span>.<span class="ident">state</span> <span class="op">=</span> <span class="ident">State::Published</span>; <span class="string">&quot;&quot;</span> }
                    <span class="kw">_</span> =&gt; <span class="string">&quot;&quot;</span>,
                },
                <span class="ident">State::Published</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::content</span>() =&gt; <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">content</span>,
                    <span class="kw">_</span> =&gt; <span class="string">&quot;&quot;</span>,
                },
            }
        }

        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() -&gt; <span class="ident">Post</span> {
            <span class="ident">Post</span> {
                <span class="ident">state</span>: <span class="ident">State::Draft</span>,
                <span class="ident">content</span>: <span class="ident">String::new</span>(),
            }
        }
    }
}
</code></pre></div>
<p>In the handler method (in this case, <code>run_methods</code>), simply write for each state which methods should work and how.</p>
<p>The macro duplicates the output for the compiler in the doc-comments. Therefore, in the IDE<sup id="fnref1"><a href="#fn1">1</a></sup>, you can always see the declaration of the generated <code>enum</code> and the generated method bodies, in the popup hint above the enum name:</p>
<p><img src="..%5Cmethods_enum-img/from_book__enum-popup.png" alt="enum popup hint" /></p>
<p><img src="..%5Cmethods_enum-img/from_book__enum-popup-bodies.png" alt="enum popup: bodies" /></p>
<p>Alternatively, the entire result of a macro can be output to the console at compile time by setting the session environment variable M_ENUM_DBG to a value other than “0”. PowerShell example:</p>
<div class="example-wrap"><pre class="language-PowerShell"><code>PS &gt; $Env:M_ENUM_DBG=1
PS &gt; cargo build</code></pre></div>
<p>This is worth doing when the compiler messages are not clear and referring to the macro line , so that for debugging, replace the impl block along with the attribute with the output of the macro.</p>
<h2 style="color: red"> Restrictions </h2>
<ul>
<li>Macro does not work on generic methods (including lifetime generics). As a general rule, methods with &lt;…&gt; before the argument list, with <code>where</code> before the body, or <code>impl</code> in the argument type declaration will be silently ignored for inclusion in <code>enum</code>.</li>
<li>Macro ignores also methods with a <code>mut</code> prefix in front of a method argument name (except  <code>self</code>): move such an argument to a mut variable in the body of the handler method.</li>
<li>The <code>self</code> form of all methods of the same <code>enum</code> must be the same and match the <code>self</code> form of the handler method. As a rule, it is either <code>&amp;mut self</code> everywhere or <code>self</code> in methods + <code>mut self</code> in the handler method. However, it is allowed to group method signatures into multiple <code>impl</code> blocks with different <code>enum</code> and handler methods. See example below.</li>
</ul>
<h2 id="details-of-the-macro-and-use-cases"><a href="#details-of-the-macro-and-use-cases">Details of the macro and use cases</a></h2>
<p>The macro reads only its impl block and only up to the name of the handler method. From which it follows that all method signatures for enum must be located before the handler method or in a separate from it impl block.</p>
<p>The following example demonstrates the use of methods with <code>self</code> in the form of a move, in a separate <code>impl</code> block from their handler, which also contains the signatures of the <code>&amp;mut self</code> methods and both handlers.</p>
<p>Let’s say that in the blog::Post task, the state-changing methods require the form <code>self</code> move, to work with dot notation, while the rest of the methods need to be left on the form <code>&amp;mut self</code>, or:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">post</span> <span class="op">=</span> <span class="ident">blog::Post::new</span>();

    <span class="ident">post</span>.<span class="ident">add_text</span>(<span class="string">&quot;I ate a salad for lunch today&quot;</span>);
    <span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());

    <span class="macro">assert_eq!</span>(
        <span class="string">&quot;I ate a salad for lunch today&quot;</span>,
        <span class="ident">post</span>.<span class="ident">request_review</span>().<span class="ident">approve</span>().<span class="ident">content</span>()
    );
}

<span class="comment">// In this case, the solution might be:</span>

<span class="kw">mod</span> <span class="ident">blog</span> {
    <span class="kw">enum</span> <span class="ident">State</span> {
        <span class="ident">Draft</span>,
        <span class="ident">PendingReview</span>,
        <span class="ident">Published</span>,
    }

    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Post</span> {
        <span class="ident">state</span>: <span class="ident">State</span>,
        <span class="ident">content</span>: <span class="ident">String</span>,
    }

    <span class="attribute">#[<span class="ident">methods_enum::gen</span>(<span class="ident">Move</span>: <span class="ident">run_move</span>)]</span>
    <span class="kw">impl</span> <span class="ident">Post</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">request_review</span>(<span class="self">self</span>) -&gt; <span class="ident">Post</span>;
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">approve</span>(<span class="self">self</span>) -&gt; <span class="ident">Post</span>;
    }

    <span class="attribute">#[<span class="ident">methods_enum::gen</span>(<span class="ident">Meth</span>: <span class="ident">run_methods</span>)]</span>
    <span class="kw">impl</span> <span class="ident">Post</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_text</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">text</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">content</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span>;

        <span class="kw">fn</span> <span class="ident">run_methods</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">method</span>: <span class="ident">Meth</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span> {
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span> {
                <span class="ident">State::Draft</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::add_text</span>(<span class="ident">text</span>) =&gt; { <span class="self">self</span>.<span class="ident">content</span>.<span class="ident">push_str</span>(<span class="ident">text</span>); <span class="string">&quot;&quot;</span> }
                    <span class="kw">_</span> =&gt; <span class="string">&quot;&quot;</span>,
                },
                <span class="ident">State::PendingReview</span> =&gt; <span class="string">&quot;&quot;</span>,
                <span class="ident">State::Published</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::content</span>() =&gt; <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">content</span>,
                    <span class="kw">_</span> =&gt; <span class="string">&quot;&quot;</span>,
                },
            }
        }

        <span class="kw">fn</span> <span class="ident">run_move</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">method</span>: <span class="ident">Move</span>) -&gt; <span class="ident">Post</span> {
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span> {
                <span class="ident">State::Draft</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Move::request_review</span>() =&gt; { <span class="self">self</span>.<span class="ident">state</span> <span class="op">=</span> <span class="ident">State::PendingReview</span>; <span class="self">self</span> }
                    <span class="kw">_</span> =&gt; <span class="self">self</span>,
                },
                <span class="ident">State::PendingReview</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Move::approve</span>() =&gt; { <span class="self">self</span>.<span class="ident">state</span> <span class="op">=</span> <span class="ident">State::Published</span>; <span class="self">self</span> }
                    <span class="kw">_</span> =&gt; <span class="self">self</span>,
                },
                <span class="ident">State::Published</span> =&gt; <span class="self">self</span>,
            }
        }

        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() -&gt; <span class="ident">Post</span> {
            <span class="ident">Post</span> {
                <span class="ident">state</span>: <span class="ident">State::Draft</span>,
                <span class="ident">content</span>: <span class="ident">String::new</span>(),
            }
        }
    }
}</code></pre></div>
<p>Here fn run_move and/or fn run_methods can also be placed at the end of the first <code>impl</code> block.</p>
<p>Associated functions (for the syntax without <em>OutName</em> also and regular methods) can be in the <code>impl</code> block and before the handler method, interspersed with method signatures, but this worsens readability.</p>
<p>Methods arguments with &amp;mut types work the same way. For example, to extend the blog::Post task to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">post</span> <span class="op">=</span> <span class="ident">blog::Post::new</span>();

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ext_content</span> <span class="op">=</span> <span class="string">&quot;external content: &quot;</span>.<span class="ident">to_string</span>();

    <span class="ident">post</span>.<span class="ident">add_text</span>(<span class="string">&quot;I ate a salad for lunch today&quot;</span>, <span class="kw-2">&amp;mut</span> <span class="ident">ext_content</span>);
    <span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());
    <span class="macro">assert_eq!</span>(<span class="string">&quot;external content: I ate a salad for lunch today&quot;</span>, <span class="ident">ext_content</span>);

    <span class="ident">post</span>.<span class="ident">request_review</span>();
    <span class="ident">post</span>.<span class="ident">approve</span>();
    <span class="macro">assert_eq!</span>(<span class="string">&quot;I ate a salad for lunch today&quot;</span>, <span class="ident">post</span>.<span class="ident">content</span>());
}

<span class="comment">// the solution might look like this:</span>

<span class="kw">mod</span> <span class="ident">blog</span> {
<span class="comment">// . . .                    </span>
<span class="comment">// . . .                    </span>
    <span class="attribute">#[<span class="ident">methods_enum::gen</span>(<span class="ident">Meth</span>: <span class="ident">run_methods</span>)]</span>
    <span class="kw">impl</span> <span class="ident">Post</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_text</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">text</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">ex_content</span>: <span class="kw-2">&amp;mut</span> <span class="ident">String</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">request_review</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">approve</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">content</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span>;

        <span class="kw">fn</span> <span class="ident">run_methods</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">method</span>: <span class="ident">Meth</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">str</span> {
            <span class="kw">match</span> <span class="self">self</span>.<span class="ident">state</span> {
                <span class="ident">State::Draft</span> =&gt; <span class="kw">match</span> <span class="ident">method</span> {
                    <span class="ident">Meth::add_text</span>(<span class="ident">text</span>, <span class="ident">ex_cont</span>) =&gt; {
                        <span class="self">self</span>.<span class="ident">content</span>.<span class="ident">push_str</span>(<span class="ident">text</span>);
                        <span class="ident">ex_cont</span>.<span class="ident">push_str</span>(<span class="ident">text</span>);
                        <span class="string">&quot;&quot;</span>
                    }
<span class="comment">// . . .                    </span>
<span class="comment">// . . .    </span>
}</code></pre></div>
<h2 id="2nd-syntax-option-with-outname"><a href="#2nd-syntax-option-with-outname">2nd syntax option: with <em>OutName</em></a></h2>
<p><strong><code>#[methods_enum::gen(</code><em>EnumName</em><code>: </code> <em>handler_name</em> <code>=</code> <em>OutName</em><code>)]</code></strong></p>
<p>where:</p>
<ul>
<li><em>OutName</em>: the name of the automatically generated enum with options from single tuples of return types.</li>
</ul>
<div class="footnotes"><hr><ol><li id="fn1"><p>IDE support tested on ‘rust-analyzer for VS Code v0.3.1083’ - everything works: highlighting, tooltips, transitions, renames.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div>
    
</body>
</html>